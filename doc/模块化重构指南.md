# 程序模块化重构指南

## 当前架构问题分析

### 主要问题
1. **职责混乱**: UI层承担了太多业务逻辑
2. **紧耦合**: 数据加载、算法计算、图表显示相互依赖
3. **代码重复**: 相似功能在多个地方重复实现
4. **测试困难**: 业务逻辑与UI紧密耦合，难以单元测试
5. **扩展困难**: 添加新功能需要修改多个文件

## 重构后的架构设计

### 分层架构
```
┌─────────────────────────────────────┐
│          Presentation Layer         │  表示层
│  ┌─────────────┐  ┌─────────────┐   │
│  │ MainWindow  │  │ ChartWidget │   │
│  └─────────────┘  └─────────────┘   │
└─────────────────────────────────────┘
                    │
┌─────────────────────────────────────┐
│         Controller Layer            │  控制器层
│  ┌─────────────┐  ┌─────────────┐   │
│  │MainController│ │ChartController│  │
│  └─────────────┘  └─────────────┘   │
└─────────────────────────────────────┘
                    │
┌─────────────────────────────────────┐
│         Service Layer               │  服务层
│ ┌──────────┐ ┌──────────┐ ┌──────┐  │
│ │DataService│ │AlgoService│ │Chart │  │
│ │          │ │          │ │Service│  │
│ └──────────┘ └──────────┘ └──────┘  │
└─────────────────────────────────────┘
                    │
┌─────────────────────────────────────┐
│         Domain Layer                │  领域层
│ ┌──────────┐ ┌──────────┐ ┌──────┐  │
│ │ KLineData│ │StockInfo │ │Chart │  │
│ │          │ │          │ │Model │  │
│ └──────────┘ └──────────┘ └──────┘  │
└─────────────────────────────────────┘
```

## 新增模块说明

### 1. 数据服务层 (`common/services/data_service.py`)
**职责**: 统一管理所有数据相关操作
- 文件数据加载
- 股票信息管理
- 数据格式转换
- 数据缓存

**优势**:
- 单一数据访问入口
- 便于切换数据源（文件→数据库）
- 数据操作统一管理

### 2. 算法服务层 (`common/services/algorithm_service.py`)
**职责**: 管理所有算法计算
- 算法注册和管理
- 算法计算统一入口
- 算法参数管理
- 计算结果缓存

**优势**:
- 算法松耦合，易于扩展
- 统一的算法接口
- 支持插件式算法

### 3. 图表服务层 (`common/services/chart_service.py`)
**职责**: 协调数据和算法，为图表提供服务
- 图表数据准备
- 算法应用管理
- 图表配置处理

**优势**:
- 数据和算法的桥梁
- 图表逻辑集中管理
- 配置驱动的图表生成

### 4. 控制器层 (`common/controllers/main_controller.py`)
**职责**: 协调UI和业务逻辑
- 用户操作处理
- 业务流程控制
- 状态管理
- 事件分发

**优势**:
- UI和业务逻辑解耦
- 便于单元测试
- 清晰的职责分工

### 5. 重构后UI层 (`common/ui/refactored_main_window.py`)
**职责**: 纯UI展示和用户交互
- 界面元素管理
- 用户事件处理
- 视图更新
- 信号槽连接

**优势**:
- UI逻辑简洁清晰
- 便于UI测试
- 易于更换UI框架

## 重构实施步骤

### 阶段1: 数据层重构 (1-2天)
1. 创建 `DataService` 类
2. 将文件读取逻辑迁移到数据服务
3. 统一数据模型定义
4. 测试数据服务功能

### 阶段2: 算法层重构 (2-3天)
1. 定义算法接口 `AlgorithmInterface`
2. 实现现有算法的包装类
3. 创建算法注册表
4. 测试算法服务功能

### 阶段3: 服务层重构 (2-3天)
1. 创建 `ChartService` 整合数据和算法
2. 实现图表配置处理逻辑
3. 测试服务层集成

### 阶段4: 控制器重构 (3-4天)
1. 创建各种控制器类
2. 实现UI和业务逻辑的解耦
3. 添加信号槽机制
4. 测试控制器功能

### 阶段5: UI重构 (2-3天)
1. 重构主窗口，移除业务逻辑
2. 实现纯UI展示功能
3. 连接控制器信号
4. 全面测试

### 阶段6: 集成测试 (1-2天)
1. 端到端功能测试
2. 性能测试
3. 错误处理测试
4. 文档更新

## 使用示例

### 旧代码 vs 新代码对比

#### 旧代码 (mixed concerns)
```python
class MainWindow(QtWidgets.QMainWindow):
    def load_data_from_file_name(self, code=""):
        # UI逻辑
        self.widget.clear_all()
        
        # 业务逻辑
        if code:
            file_name = self.code_file_dic[code]
            self.conf["plots"][0]["chart_item"][0]["file_name"] = file_name
        
        # 数据加载
        datas = load_data_from_conf(self.conf)
        
        # 算法计算
        self.widget.update_all_history_data(datas, obtain_data_from_algo)
        
        # 更多UI逻辑...
```

#### 新代码 (separated concerns)
```python
class RefactoredMainWindow(QtWidgets.QMainWindow):
    def _on_data_loaded(self, chart_data):
        # 纯UI逻辑
        self.chart_controller.update_chart_data(chart_data)

class MainController:
    def switch_stock(self, stock_code):
        # 纯业务逻辑
        stock_info = self.data_service.find_stock_by_code(stock_code)
        chart_data = self.chart_service.update_chart_file(self.config, stock_info.file_name)
        self.data_loaded.emit(chart_data)
```

## 重构收益

### 1. 可维护性提升
- 职责明确，修改影响范围小
- 代码结构清晰，易于理解
- 依赖关系明确

### 2. 可测试性提升
- 各层独立，便于单元测试
- Mock依赖容易实现
- 测试覆盖率可以提升

### 3. 可扩展性提升
- 新增算法只需实现接口
- 新增数据源只需实现仓储接口
- 新增图表类型配置化

### 4. 性能优化空间
- 数据缓存统一管理
- 算法计算可以异步化
- 按需加载机制

### 5. 团队协作改善
- 不同开发者可以并行工作在不同层
- 代码审查更容易
- 知识转移成本降低

## 迁移指南

### 立即迁移 (低风险)
1. 新功能使用新架构开发
2. 工具类函数迁移到服务层
3. 数据模型统一定义

### 逐步迁移 (中等风险)
1. 一个功能模块一个功能模块迁移
2. 保持新旧代码兼容
3. 充分测试后替换

### 完全重写 (高风险，高收益)
1. 基于新架构重新实现
2. 功能对等验证
3. 性能对比测试

## 注意事项

1. **保持向后兼容**: 重构过程中不要破坏现有功能
2. **充分测试**: 每个阶段都要有对应的测试
3. **文档更新**: 及时更新架构文档和使用说明
4. **性能监控**: 重构可能影响性能，需要持续监控
5. **团队培训**: 新架构需要团队成员学习适应

## 总结

通过模块化重构，我们可以将当前混乱的代码结构改造成清晰的分层架构，每一层都有明确的职责。这不仅提高了代码的可维护性和可测试性，也为后续的功能扩展和性能优化打下了坚实的基础。

重构是一个渐进的过程，建议从低风险的部分开始，逐步推进，确保每一步都能带来实际的收益。